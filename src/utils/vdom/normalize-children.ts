import { isPrimitive } from "@utils/index";
import { createTextVNode } from "@vdom/vnode";
import { isUndef,isDef,isFalse, isTrue } from "@utils/assert";

function isTextNode (node:any): boolean {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
// 如果有一个child是数组则将children与空数组相连 ?? mark
export function simpleNormalizeChildren(children: any) {
  for(let i=0;i<children.length;i++){
    if(Array.isArray(children[i])){
      return Array.prototype.concat.apply([],children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
export function normalizeChildren(children: any): Array<VNodeInstance> | void {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined;
}

// 合并children 之间相连的 primitive || text
// 为 v-for child 生成 key
// if c is arr 递归 
function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNodeInstance> {
  const res:any[] = [];
  let i,c,lastIndex,last;
  for(i=0;i<children.length;i++){
    c = children[i];
    // 忽略 null || boolean
    if(isUndef(c) || typeof c === 'boolean') continue;
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    // 如果当前child是数组且第一个元素是text,则将文本合并至last
    // res.push(c)
    if(Array.isArray(c)){
      // 合并text node
      if(c.length > 0){
        c = normalizeArrayChildren(c,`${nestedIndex || ''}_${i}`);
        // merge adjacent text nodes
        if(isTextNode(c[0]) && isTextNode(last)){
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res,c);
      }

      // last 是文本节点且当前属于初始对象则合并至last,否则新增textVnode
    }else if(isPrimitive(c)){
      // 合并text
      if(isTextNode(last)){
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);

        // 新增text node
      }else if(c !== ''){
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      // cur && last is text 则合并至 last
      if(isTextNode(c) && isTextNode(last)){
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      }else{
        // default key for nested array children (likely generated by v-for)
        // 为v-for renderList 生成的children[i] 添加 默认 key
        if(isTrue(children._isVList)
          && isDef(c.tag)
          && isUndef(c.key)
          && isDef(nestedIndex)){
            c.key = `__vlist${nestedIndex}_${i}__`;
        }
        res.push(c);
      }
    }
  }
  return res;
}